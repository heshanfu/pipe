/**
 * Copyright (c) 2018 Udey Rishi. All rights reserved.
 */
package com.udeyrishi.pipe.barrier

import com.udeyrishi.pipe.steps.Step
import com.udeyrishi.pipe.util.SortReplayer
import kotlinx.coroutines.experimental.launch

interface CountedBarrierController {
    var capacity: Int
}

internal class CountedBarrierControllerImpl<T : Comparable<T>>(capacity: Int = Int.MAX_VALUE, private val onBarrierLiftedAction: Step<List<T>>? = null) : BarrierController<T>, CountedBarrierController {
    override var capacity: Int = capacity
        set(value) {
            synchronized(lock) {
                if (registeredCount > value) {
                    throw IllegalStateException("Cannot change the capacity from $capacity to $value, because $registeredCount items have already been registered.")
                }
                field = value
                if (arrivalCount == value) {
                    // We now need to retroactively mark the last arrived input as the final input. Usually, the last arrival's coroutine can be reused for aggregation purposes, but it's blocked
                    // on the barrier now. So temporarily create a new one to do the aggregation + unblocking work.
                    onFinalInputPushed()
                }
            }
        }

    private val lock = Any()
    private var arrivalCount: Int = 0
        set(value) {
            if (value > registeredCount) {
                throw IllegalStateException("Something went wrong. arrivalCount must never exceed the registeredCount.")
            }
            field = value
        }

    private var registeredCount: Int = 0
        set(value) {
            if (value > capacity) {
                throw IllegalStateException("Something went wrong. ${this::class.java.simpleName} has reached its maximum capacity of $capacity, but another barrier was registered.")
            }
            field = value
        }

    // Registered barrier to whether it's blocked or not
    private val barriers = mutableMapOf<Barrier<T>, Boolean>()

    override fun onBarrierCreated(barrier: Barrier<T>) {
        synchronized(lock) {
            if (barriers.contains(barrier)) {
                throw IllegalArgumentException("Cannot register $barrier 2x.")
            }
            ++registeredCount
            barriers.put(barrier, false)
        }
    }

    override fun onBarrierBlocked(barrier: Barrier<T>) {
        synchronized(lock) {
            if (barrier !in barriers) {
                throw IllegalArgumentException("Barrier $barrier was never registered.")
            }
            if (barriers[barrier] == true) {
                throw IllegalArgumentException("Barrier $barrier was already marked as blocked.")
            }
            barriers[barrier] = true
            ++arrivalCount
            if (arrivalCount == capacity) {
                onFinalInputPushed()
            }
        }
    }

    private fun onFinalInputPushed() {
        if (barriers.any { !it.value }) {
            throw IllegalStateException("All registered barriers must have been blocked by now. Something went wrong.")
        }

        val unsortedInputs = barriers.keys.map {
            it.input ?: throw IllegalStateException("Barrier.input should've been generated by the time onBarrierBlocked was called.")
        }

        if (onBarrierLiftedAction == null) {
            liftBarriers(unsortedInputs)
            return
        }

        val sortedInputs = unsortedInputs.sorted()
        val sortReplayer = SortReplayer(original = unsortedInputs, sorted = sortedInputs)

        launch {
            val sortedOutputs = onBarrierLiftedAction.invoke(sortedInputs.map { it })
            val unsortedOutputs = sortReplayer.reverseApplySortTransformations(sortedOutputs)
            liftBarriers(unsortedOutputs)
        }
    }

    private fun liftBarriers(results: List<T>) {
        barriers.keys.zip(results).forEach { (barrier, result) ->
            barrier.lift(result)
        }
        barriers.clear()
    }
}
